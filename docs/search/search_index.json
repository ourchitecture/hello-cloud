{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello Cloud Our Mission The \"Hello Cloud\" project seeks to provide an objective, hands-on approach to cloud computing; where observations are made with interactive examples. Just how easy is it for a developer to automate a basic \"hello world\" program in the cloud? While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial; creating infrastructure and deploying code is often demonstrated via graphical interface rather than completely through automation. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by workflows of DevOps toolchains and pipelines for continuous integration and deployment (CI/CD). Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. Contribute Issues Star Watch Fork flowchart LR subgraph cloud [Cloud Provider] aws([Amazon Web Services]) azure([Microsoft Azure]) gcloud([Google Cloud]) heroku([Salesforce Heroku]) end subgraph compute [Compute Abstraction] function(Functions) application(Applications) container(Containers) orchestration(Container Orchestration) end aws --o|AWS Lamda| function aws --o|AWS Elastic Beanstalk| application aws --o|AWS Elastic Beanstalk| container aws --o|\"AWS Elastic Kubernetes Service (EKS)\"| orchestration azure --o|Azure Functions| function azure --o|Azure AppService| application azure --o|Azure AppService| container azure --o|\"Azure Kubernetes Service (AKS)\"| orchestration gcloud --o|Google Cloud Functions| function gcloud --o|Google Cloud Run| function gcloud --o|Google AppEngine| application gcloud --o|Google Cloud Run| application gcloud --o|Google AppEngine| container gcloud --o|Google Cloud Run| container gcloud --o|\"Google Kubernetes Engine (GKE)\"| orchestration heroku --o|Heroku Dynos| application heroku --o|Heroku Dynos| container Mapping Cloud Providers to Compute Abstractions Each compute abstraction builds on the last Functions For the purposes of this effort, Cloud Functions allows the developer to generally focus on the programming language, libraries and integrations without worrying about an application runtime. The term \"Serverless\" or the phrase \"Functions as a Service\" (FaaS) usually refer to this type of deployment. Applications This type of deployment allows the developer to focus on the application's programming language, libraries, integrations, application runtime, and frameworks without worrying about containers with an Operating System, Middleware, and the patching that comes with it. There is some nuance to the phrase \"Platform as a Service\" (PaaS); generally, the use of PaaS often refers to this type of deployment. Of course, a cloud provider may be using containers behind the scenes. Containers Managed containers allow the developer to containerize their system and rely on the cloud for container deployment, scaling and management. Container Orchestration Managed Kubernetes offerings are the ubiquitous technology supporting this type of deployment. Here, developers rely on the cloud to setup and manage a Kubernetes installation, but must configure and manage the installation, including containers. Clouds Amazon Web Services Microsoft Azure Google Cloud Salesforce Heroku *See the \"Cloud Comparisons\" for more general comparisons of each cloud's service offerings. Projects .NET Java with SpringBoot Kotlin with SpringBoot NodeJS with ExpressJS Resources Make a contribution Learn about the DevOps pipeline See where things are headed on the roadmap","title":"Home"},{"location":"#hello-cloud","text":"Our Mission The \"Hello Cloud\" project seeks to provide an objective, hands-on approach to cloud computing; where observations are made with interactive examples. Just how easy is it for a developer to automate a basic \"hello world\" program in the cloud? While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial; creating infrastructure and deploying code is often demonstrated via graphical interface rather than completely through automation. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by workflows of DevOps toolchains and pipelines for continuous integration and deployment (CI/CD). Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. Contribute Issues Star Watch Fork flowchart LR subgraph cloud [Cloud Provider] aws([Amazon Web Services]) azure([Microsoft Azure]) gcloud([Google Cloud]) heroku([Salesforce Heroku]) end subgraph compute [Compute Abstraction] function(Functions) application(Applications) container(Containers) orchestration(Container Orchestration) end aws --o|AWS Lamda| function aws --o|AWS Elastic Beanstalk| application aws --o|AWS Elastic Beanstalk| container aws --o|\"AWS Elastic Kubernetes Service (EKS)\"| orchestration azure --o|Azure Functions| function azure --o|Azure AppService| application azure --o|Azure AppService| container azure --o|\"Azure Kubernetes Service (AKS)\"| orchestration gcloud --o|Google Cloud Functions| function gcloud --o|Google Cloud Run| function gcloud --o|Google AppEngine| application gcloud --o|Google Cloud Run| application gcloud --o|Google AppEngine| container gcloud --o|Google Cloud Run| container gcloud --o|\"Google Kubernetes Engine (GKE)\"| orchestration heroku --o|Heroku Dynos| application heroku --o|Heroku Dynos| container Mapping Cloud Providers to Compute Abstractions Each compute abstraction builds on the last Functions For the purposes of this effort, Cloud Functions allows the developer to generally focus on the programming language, libraries and integrations without worrying about an application runtime. The term \"Serverless\" or the phrase \"Functions as a Service\" (FaaS) usually refer to this type of deployment. Applications This type of deployment allows the developer to focus on the application's programming language, libraries, integrations, application runtime, and frameworks without worrying about containers with an Operating System, Middleware, and the patching that comes with it. There is some nuance to the phrase \"Platform as a Service\" (PaaS); generally, the use of PaaS often refers to this type of deployment. Of course, a cloud provider may be using containers behind the scenes. Containers Managed containers allow the developer to containerize their system and rely on the cloud for container deployment, scaling and management. Container Orchestration Managed Kubernetes offerings are the ubiquitous technology supporting this type of deployment. Here, developers rely on the cloud to setup and manage a Kubernetes installation, but must configure and manage the installation, including containers.","title":"Hello Cloud"},{"location":"#clouds","text":"Amazon Web Services Microsoft Azure Google Cloud Salesforce Heroku *See the \"Cloud Comparisons\" for more general comparisons of each cloud's service offerings.","title":"Clouds"},{"location":"#projects","text":".NET Java with SpringBoot Kotlin with SpringBoot NodeJS with ExpressJS","title":"Projects"},{"location":"#resources","text":"Make a contribution Learn about the DevOps pipeline See where things are headed on the roadmap","title":"Resources"},{"location":"clouds/","text":"Clouds Following are some interesting cloud observations while developing basic, automated hello-world deployments for each. Defined While each cloud provider provides their own definition for cloud computing (e.g. AWS, Azure, Google, RedHat, etc.), one historical standard was set forth by the National Institute of Standards and Technology (NIST), U.S. Department of Commerce , titled \"The NIST Definition of Cloud Computing\" . The NIST Definition of Cloud Computing... Essential Characteristics On-demand self-service. A consumer can unilaterally provision computing capabilities, such as server time and network storage, as needed automatically without requiring human interaction with each service provider. Broad network access. Capabilities are available over the network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms (e.g., mobile phones, tablets, laptops, and workstations). Resource pooling. The provider's computing resources are pooled to serve multiple consumers using a multi-tenant model, with different physical and virtual resources dynamically assigned and reassigned according to consumer demand. There is a sense of location independence in that the customer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter). Examples of resources include storage, processing, memory, and network bandwidth. Rapid elasticity. Capabilities can be elastically provisioned and released, in some cases automatically, to scale rapidly outward and inward commensurate with demand. To the consumer, the capabilities available for provisioning often appear to be unlimited and can be appropriated in any quantity at any time. Measured service. Cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Resource usage can be monitored, controlled, and reported, providing transparency for both the provider and consumer of the utilized service. Service Models Software as a Service (SaaS). The capability provided to the consumer is to use the provider's applications running on a cloud infrastructure. The applications are accessible from various client devices through either a thin client interface, such as a web browser (e.g., web-based email), or a program interface. The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user - specific application configuration settings. Platform as a Service (PaaS). The capability provided to the consumer is to deploy onto the cloud infrastructure consumer -created or acquired applications created using programming languages, libraries, services, and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, or storage, but has control over the deployed applications and possibly configuration settings for the application-hosting environment. Infrastructure as a Service (IaaS). The capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, and deployed applications; and possibly limited control of select networking components (e.g., host firewalls). Deployment Models Private cloud. The cloud infrastructure is provisioned for exclusive use by a single organization comprising multiple consumers (e.g., business units) . It may be owned, managed, and operated by the organization, a third party, or some combination of them, and it may exist on or off premises. Community cloud. The cloud infrastructure is provisioned for exclusive use by a specific community of consumers from organizations that have shared concerns (e.g., mission, security requirements, policy, and compliance considerations). It may be owned, managed, and operated by one or more of the organizations in the community, a third party, or some combination of them, and it may exist on or off premises. Public cloud. The cloud infrastructure is provisioned for open use by the general public. It may be owned, managed, and operated by a business, academic, or government organization, or some combination of them. It exists on the premises of the cloud provider. Hybrid cloud. The cloud infrastructure is a composition of two or more distinct cloud infrastructures (private, community, or public) that remain unique entities, but are bound together by standardized or proprietary technology that enables data and application portability (e.g., cloud bursting for load balancing between clouds). Cloud Deployment Types Building on the NIST definitions, BMC has provided a list of things to consider when comparing the cloud deployment types below. Key benefits & drawbacks of cloud computing types Choosing a cloud abstraction is an architecture decision with significant impacts to end-to-end system design, development, testing, integration and deployment, and operations and support. Traditional models compare the ownership concerns when targeting on-site, Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and/or Software as a Service (SaaS). However, cloud has continued to evolve and blur the boundaries between these deployment models. This project offers this example as a guide: Cloud Computing Abstractions Cloud Computing Packages Cloud Providers Below is a summary of each cloud provider and the \"hello-cloud\" experience. Check out the cloud comparisons to see how their more general offerings stack up. Amazon Web Services Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights For PaaS deployments, the behind-the-scenes integrations across PaaS with Elastic Beanstalk, Infrastructure as Code with CloudFormation, and Configuration Management with OpsWorks were fairly seamless. For PaaS deployments, Creating and destroying cloud infrastructure for deployment was straightforward, but takes some time. For PaaS deployments, deployments of supported programming languages and versions was easy, despite being behind in supporting the most recent LTS versions for a few languages. Some hello-cloud challenges Resources were not free with a small daily charge for a \"hello-cloud\" project. But, that daily charge adds up when developing and testing deployments multiple times. For PaaS deployments, there is a chance creating and destroying \"hello-world\" deployments repeatedly may result in residual cloud artifacts. More detailed investigation needs to confirm that everything is removed during a cloud uninstall. CLI errors could benefit from machine-readable names and codes in the output (e.g. \"ResourceNotFound\"). Separate CLIs for AWS ( aws ), Elastic Beanstalk ( eb ) and a .NET CLI plug-in ( dotnet aws ) were required. Generally, the separation seems beneficial, but there is cognitive overlap across aws elasticbeanstalk and eb as well as eb deploy and dotnet aws deploy . The dotnet aws deploy command also has prerequisite dependencies on Node.js and Docker. PaaS tooling support for .NET internally utilizes a containerized deployment on the local machine rather than deploying the .NET code to the cloud and allowing the PaaS to make the necessary cloud infrastructure (container) steps internally. Running production containers locally could offer some advantages for developers trying to replicate production issues, but containerization seemed to be a short-lived cloud deploy step. PaaS support for Java and Kotlin using Elastic Beanstalk and Corretto 11 complains during eb deploy with \"Alert: The platform version that your environment is using isn't recommended. There's a recommended version in the same platform branch.\" This is because specifying eb init --platform corretto-11 ... defaults to version \"3.2.7\", when a newer platform version exists on AWS. Contributions to fix this with a specific platform version are welcomed. Microsoft Azure Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! The process to create and destroy cloud infrastructure was fast for this project's needs PaaS deployments \"just worked\" For PaaS, the Java Maven plug-in includes a lot of automation. It would be great to have these capabilities exist outside of Maven and/or Gradle to support developer choice. The new CLI az config ... command is incredibly convenient, but could make the actions of downstream commands less explicit; forcing developers to review command log history to discover earlier contextual defaults. Some hello-cloud challenges Without the \"runtime\" command argument (e.g. az webapp up ... --runtime DOTNET|6.0 ), the PaaS tooling failed to deploy a .NET Core 6.0 project (e.g. \" net6.0 \") with the error \"Windows runtime 'aspnet|4.8' is not supported.\" The error's assumption about .NET 4.8 is odd, when we consider that this is a Microsoft programming language project being deployed to a Microsoft PaaS cloud and the version was not properly discovered. Java and Kotlin PaaS support was challenging as it seems they only support a Maven plug-in, eliminating the ability for projects that target Azure to use Gradle. This is an odd choice, considering Gradle is perhaps equally or more popular than Maven for modern development and the entire Android ecosystem utilizes Gradle. Google Cloud Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! Container deployments \"just work\" Some hello-cloud challenges We could not automate 100% of the cloud infrastructure deployment and configuration. Manual intervention was required to associate a project with billing as well as to enable Cloud Build. Is it possible to automate this? CLI errors could benefit from machine-readable names and codes in the output (e.g. \"ResourceNotFound\"). Automatically setting up and tearing down PaaS infrastructure seems slow and idempotency was challenging. The command gcloud app deploy ... does not seem to properly ignore a relative root \"./Dockerfile\", even if the \"./app.yaml\" specifies a standard runtime (not \"custom\" for docker containers), even when the file \"./.gcloudignore\" explicitly ignores \"Dockerfile\". Salesforce Heroku Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes - not applicable. See \"converting Kubernetes to Heroku containers\" . Machine Learning - not applicable Marketplace Platform as a Service (PaaS) Serverless - not applicable Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! For PaaS deployments, supported programming languages and versions \"just work\" hello-cloud challenges Does not work out-of-the-box with monorepos, requiring the use of an unsupported community user buildpack . Heroku also uses a git repository to push code changes. The entire monorepo would have to be synchronized with the Heroku repo. As a result, the heroku CLI was containerized with just the application code, initializing an empty git repository within (local to) the container and the code files were added and committed. This was sufficient to synchronize only the application's code with Heroku. Heroku tooling complains when a \"shallow clone\" is made (e.g. git clone --depth=1 ... ); history is required. Just like the monorepo problem, containerizing the heroku CLI and application code avoid this problem. .NET Core is not an officially supported language, requiring the use of an unsupported community user buildpack ( * forked to ourchitecture ). This is odd, considering C# has been in the top lists of programming languages for professional developers for several years. Technology Java and Kotlin hello-cloud challenges Some vendor Platform as a Service (PaaS) solutions are limited to Java 11 with Long-Term Support (LTS), despite the OpenJDK being released every 6 months including newer LTS versions (e.g. v17). Newer Java versions may use containers and examples are provided. See the Oracle Java SE support roadmap for more.","title":"Clouds"},{"location":"clouds/#clouds","text":"Following are some interesting cloud observations while developing basic, automated hello-world deployments for each.","title":"Clouds"},{"location":"clouds/#defined","text":"While each cloud provider provides their own definition for cloud computing (e.g. AWS, Azure, Google, RedHat, etc.), one historical standard was set forth by the National Institute of Standards and Technology (NIST), U.S. Department of Commerce , titled \"The NIST Definition of Cloud Computing\" . The NIST Definition of Cloud Computing...","title":"Defined"},{"location":"clouds/#essential-characteristics","text":"On-demand self-service. A consumer can unilaterally provision computing capabilities, such as server time and network storage, as needed automatically without requiring human interaction with each service provider. Broad network access. Capabilities are available over the network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms (e.g., mobile phones, tablets, laptops, and workstations). Resource pooling. The provider's computing resources are pooled to serve multiple consumers using a multi-tenant model, with different physical and virtual resources dynamically assigned and reassigned according to consumer demand. There is a sense of location independence in that the customer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter). Examples of resources include storage, processing, memory, and network bandwidth. Rapid elasticity. Capabilities can be elastically provisioned and released, in some cases automatically, to scale rapidly outward and inward commensurate with demand. To the consumer, the capabilities available for provisioning often appear to be unlimited and can be appropriated in any quantity at any time. Measured service. Cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Resource usage can be monitored, controlled, and reported, providing transparency for both the provider and consumer of the utilized service.","title":"Essential Characteristics"},{"location":"clouds/#service-models","text":"Software as a Service (SaaS). The capability provided to the consumer is to use the provider's applications running on a cloud infrastructure. The applications are accessible from various client devices through either a thin client interface, such as a web browser (e.g., web-based email), or a program interface. The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user - specific application configuration settings. Platform as a Service (PaaS). The capability provided to the consumer is to deploy onto the cloud infrastructure consumer -created or acquired applications created using programming languages, libraries, services, and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, or storage, but has control over the deployed applications and possibly configuration settings for the application-hosting environment. Infrastructure as a Service (IaaS). The capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, and deployed applications; and possibly limited control of select networking components (e.g., host firewalls).","title":"Service Models"},{"location":"clouds/#deployment-models","text":"Private cloud. The cloud infrastructure is provisioned for exclusive use by a single organization comprising multiple consumers (e.g., business units) . It may be owned, managed, and operated by the organization, a third party, or some combination of them, and it may exist on or off premises. Community cloud. The cloud infrastructure is provisioned for exclusive use by a specific community of consumers from organizations that have shared concerns (e.g., mission, security requirements, policy, and compliance considerations). It may be owned, managed, and operated by one or more of the organizations in the community, a third party, or some combination of them, and it may exist on or off premises. Public cloud. The cloud infrastructure is provisioned for open use by the general public. It may be owned, managed, and operated by a business, academic, or government organization, or some combination of them. It exists on the premises of the cloud provider. Hybrid cloud. The cloud infrastructure is a composition of two or more distinct cloud infrastructures (private, community, or public) that remain unique entities, but are bound together by standardized or proprietary technology that enables data and application portability (e.g., cloud bursting for load balancing between clouds).","title":"Deployment Models"},{"location":"clouds/#cloud-deployment-types","text":"Building on the NIST definitions, BMC has provided a list of things to consider when comparing the cloud deployment types below. Key benefits & drawbacks of cloud computing types Choosing a cloud abstraction is an architecture decision with significant impacts to end-to-end system design, development, testing, integration and deployment, and operations and support. Traditional models compare the ownership concerns when targeting on-site, Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and/or Software as a Service (SaaS). However, cloud has continued to evolve and blur the boundaries between these deployment models. This project offers this example as a guide: Cloud Computing Abstractions Cloud Computing Packages","title":"Cloud Deployment Types"},{"location":"clouds/#cloud-providers","text":"Below is a summary of each cloud provider and the \"hello-cloud\" experience. Check out the cloud comparisons to see how their more general offerings stack up.","title":"Cloud Providers"},{"location":"clouds/#amazon-web-services","text":"Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights For PaaS deployments, the behind-the-scenes integrations across PaaS with Elastic Beanstalk, Infrastructure as Code with CloudFormation, and Configuration Management with OpsWorks were fairly seamless. For PaaS deployments, Creating and destroying cloud infrastructure for deployment was straightforward, but takes some time. For PaaS deployments, deployments of supported programming languages and versions was easy, despite being behind in supporting the most recent LTS versions for a few languages. Some hello-cloud challenges Resources were not free with a small daily charge for a \"hello-cloud\" project. But, that daily charge adds up when developing and testing deployments multiple times. For PaaS deployments, there is a chance creating and destroying \"hello-world\" deployments repeatedly may result in residual cloud artifacts. More detailed investigation needs to confirm that everything is removed during a cloud uninstall. CLI errors could benefit from machine-readable names and codes in the output (e.g. \"ResourceNotFound\"). Separate CLIs for AWS ( aws ), Elastic Beanstalk ( eb ) and a .NET CLI plug-in ( dotnet aws ) were required. Generally, the separation seems beneficial, but there is cognitive overlap across aws elasticbeanstalk and eb as well as eb deploy and dotnet aws deploy . The dotnet aws deploy command also has prerequisite dependencies on Node.js and Docker. PaaS tooling support for .NET internally utilizes a containerized deployment on the local machine rather than deploying the .NET code to the cloud and allowing the PaaS to make the necessary cloud infrastructure (container) steps internally. Running production containers locally could offer some advantages for developers trying to replicate production issues, but containerization seemed to be a short-lived cloud deploy step. PaaS support for Java and Kotlin using Elastic Beanstalk and Corretto 11 complains during eb deploy with \"Alert: The platform version that your environment is using isn't recommended. There's a recommended version in the same platform branch.\" This is because specifying eb init --platform corretto-11 ... defaults to version \"3.2.7\", when a newer platform version exists on AWS. Contributions to fix this with a specific platform version are welcomed.","title":"Amazon Web Services "},{"location":"clouds/#microsoft-azure","text":"Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! The process to create and destroy cloud infrastructure was fast for this project's needs PaaS deployments \"just worked\" For PaaS, the Java Maven plug-in includes a lot of automation. It would be great to have these capabilities exist outside of Maven and/or Gradle to support developer choice. The new CLI az config ... command is incredibly convenient, but could make the actions of downstream commands less explicit; forcing developers to review command log history to discover earlier contextual defaults. Some hello-cloud challenges Without the \"runtime\" command argument (e.g. az webapp up ... --runtime DOTNET|6.0 ), the PaaS tooling failed to deploy a .NET Core 6.0 project (e.g. \" net6.0 \") with the error \"Windows runtime 'aspnet|4.8' is not supported.\" The error's assumption about .NET 4.8 is odd, when we consider that this is a Microsoft programming language project being deployed to a Microsoft PaaS cloud and the version was not properly discovered. Java and Kotlin PaaS support was challenging as it seems they only support a Maven plug-in, eliminating the ability for projects that target Azure to use Gradle. This is an odd choice, considering Gradle is perhaps equally or more popular than Maven for modern development and the entire Android ecosystem utilizes Gradle.","title":"Microsoft Azure "},{"location":"clouds/#google-cloud","text":"Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes Machine Learning Marketplace Platform as a Service (PaaS) Serverless Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! Container deployments \"just work\" Some hello-cloud challenges We could not automate 100% of the cloud infrastructure deployment and configuration. Manual intervention was required to associate a project with billing as well as to enable Cloud Build. Is it possible to automate this? CLI errors could benefit from machine-readable names and codes in the output (e.g. \"ResourceNotFound\"). Automatically setting up and tearing down PaaS infrastructure seems slow and idempotency was challenging. The command gcloud app deploy ... does not seem to properly ignore a relative root \"./Dockerfile\", even if the \"./app.yaml\" specifies a standard runtime (not \"custom\" for docker containers), even when the file \"./.gcloudignore\" explicitly ignores \"Dockerfile\".","title":"Google Cloud "},{"location":"clouds/#salesforce-heroku","text":"Register for a free account . About Architecture Blueprints Calculator Compliance Console / Portal / Dashboard Containers Kubernetes - not applicable. See \"converting Kubernetes to Heroku containers\" . Machine Learning - not applicable Marketplace Platform as a Service (PaaS) Serverless - not applicable Storage Training / Learning / Education Why? What? Some hello-cloud highlights Resources were free for this project! For PaaS deployments, supported programming languages and versions \"just work\" hello-cloud challenges Does not work out-of-the-box with monorepos, requiring the use of an unsupported community user buildpack . Heroku also uses a git repository to push code changes. The entire monorepo would have to be synchronized with the Heroku repo. As a result, the heroku CLI was containerized with just the application code, initializing an empty git repository within (local to) the container and the code files were added and committed. This was sufficient to synchronize only the application's code with Heroku. Heroku tooling complains when a \"shallow clone\" is made (e.g. git clone --depth=1 ... ); history is required. Just like the monorepo problem, containerizing the heroku CLI and application code avoid this problem. .NET Core is not an officially supported language, requiring the use of an unsupported community user buildpack ( * forked to ourchitecture ). This is odd, considering C# has been in the top lists of programming languages for professional developers for several years.","title":"Salesforce Heroku "},{"location":"clouds/#technology","text":"","title":"Technology"},{"location":"clouds/#java-and-kotlin","text":"hello-cloud challenges Some vendor Platform as a Service (PaaS) solutions are limited to Java 11 with Long-Term Support (LTS), despite the OpenJDK being released every 6 months including newer LTS versions (e.g. v17). Newer Java versions may use containers and examples are provided. See the Oracle Java SE support roadmap for more.","title":"Java  and Kotlin "},{"location":"comments/","text":"Comments Welcome to \"hello-cloud\". We try our best to make sure that the discussions on our articles are the troll, spam and abuse free but we're not omnipresent. The comment section can be a great place for interaction with readers, writers and even for spawning stimulating conversation \u2013 it can be a great place for all of us! To ensure that we all have a great experience, please make sure to stick to the following guidelines: The Rules Be polite. Do not be rude to anyone and respect others. If something you would say would get you bottled on the head offline, please do not say it here. Remember there is a person behind the screen and that your words affect people. Do not troll. We appreciate and welcome criticism towards writers here, but comments that add no value to the discussion or that are merely insulting would be deleted without exception. Spam? Goodbye! We understand that you may make thousands of dollars spewing garbage, however, we are not interested. Please refrain from posting or we will give you a hand and show both you and your post out the door. To put it in a simple sentence, our guidelines boil down to \"Don't be a jerk\". If you don't follow any of these guidelines, not only will our moderators remove the comment but we may also ban you from participating in the community. If you find any comments which violate our guidelines, please make sure to 'flag' or 'mark as spam' \u2013 our moderators highly appreciate your support! Happy commenting!","title":"Comments"},{"location":"comments/#comments","text":"Welcome to \"hello-cloud\". We try our best to make sure that the discussions on our articles are the troll, spam and abuse free but we're not omnipresent. The comment section can be a great place for interaction with readers, writers and even for spawning stimulating conversation \u2013 it can be a great place for all of us! To ensure that we all have a great experience, please make sure to stick to the following guidelines: The Rules Be polite. Do not be rude to anyone and respect others. If something you would say would get you bottled on the head offline, please do not say it here. Remember there is a person behind the screen and that your words affect people. Do not troll. We appreciate and welcome criticism towards writers here, but comments that add no value to the discussion or that are merely insulting would be deleted without exception. Spam? Goodbye! We understand that you may make thousands of dollars spewing garbage, however, we are not interested. Please refrain from posting or we will give you a hand and show both you and your post out the door. To put it in a simple sentence, our guidelines boil down to \"Don't be a jerk\". If you don't follow any of these guidelines, not only will our moderators remove the comment but we may also ban you from participating in the community. If you find any comments which violate our guidelines, please make sure to 'flag' or 'mark as spam' \u2013 our moderators highly appreciate your support! Happy commenting!","title":"Comments"},{"location":"compare/","text":"Cloud Comparisons There are a number of general methods to compare these popular cloud offerings without getting too specific that the documentation is always out of date. Compare Cloud Development Tools Command-Line Interface (CLI) All clouds offer a local installation as well as an online version. Software Development Kit (SDK) SDKs will vary based on the specific type of services, the preferred programming language, and style of cloud platform interaction. AWS Azure GCP Javascript, Python, PHP, .NET, Ruby, Java, Go, Node.js, C++ .NET, Java, JavaScript, Python, GO, C++, C, PHP, Ruby GCloud CLI Web, Native Mobile, Internet of Things (IoT), IDE extensions / plug-ins, Command-Line Internet of Things (IoT), Apple Native Mobile Google APIs Web Consoles Comparison AWS Azure GCP Service Name Management Console Portal Cloud Console Cloud Developer Tools Comparison AWS Azure GCP Service Name Cloud9 Visual Studio Code Cloud Code IDE Online Experience Yes Yes Yes Supports A variety of programming languages, real-time collaboration, container development, build, test, and debugging code Implements a comparable online version of VS Code Integrates into common developer tools Infrastructure as Code Comparison AWS Azure GCP Service Name CloudFormation Azure Resource Manager (ARM) Templates Deployment Manager Language YAML JSON with Bicep (domain-specific language) YAML Terraform Yes Yes Yes Local Developer Tools Ultimately, developers may choose to run any choice of local developer tools and all clouds support the ability to run the artifacts from all languages in some form (e.g. Serverless, PaaS, Containers, or IaaS). Developer Tool Resources Tool AWS Azure GCP Developer Tools AWS developer tools Azure developer tools GCP developer tools CLI AWS CLI Azure CLI GCP CLI SDKs AWS SDKs Azure SDKs Google Cloud SDK Management AWS Management Console Microsoft Azure Portal Google Cloud Console Developer Environments AWS Cloud9 Visual Studio Code Google Cloud Code IDE Infrastructure as Code AWS CloudFormation Azure Resource Manager Google Cloud Deployment Manager Compare Cloud Storage Object Storage Comparison AWS Azure GCP Service Name Simple Storage Service (S3) BLOB Storage Cloud Storage Container Name Bucket Container Bucket Versioning, Encryption, Fine-grained security Yes Yes Yes Less frequently accessed data Infrequently accessed Cool BLOB Nearline, Coldline Archiving Glacier Archive Archive Lifecycle management Yes Yes Yes File Storage Comparison AWS Azure GCP Service Name Elastic File System (EFS) Amazon FSx for Windows Amazon FSx for Lustre Files Filestore Block Storage Great for virtual machines, this storage method provides high performance with high IOPS. Comparison AWS Azure GCP Service Name Elastic Block Storage (EBS) Azure Managed Disks Persistent disks & Solid-state disks Flexible storage type and IOPS provisioning Yes Yes Yes Scheduled and ad-hoc snapshots Yes Yes Yes Data Transport While all clouds provide web interfaces and command-line tools for uploads, Azure and Amazon also offer localized data sync \"transfer gateways\" to upload. All clouds also offer hard drive data transfer by mail. Azure offers Data Box Disk with up to 40 TB and Azure Data Box Heavy up to 1 PB. Google Cloud offers their \"Transfer Appliance\" for up to 1 PB. The Amazon Web Services \"Snow Family\" has the most variety of physical transfer options including their \"Snowmobile\", a tractor trailer that can transfer up to 100 PB of data. More comparisons... Check out A Cloud Guru Cloud Comparison videos . Consider contributing more comparisons to this page.","title":"Comparisons"},{"location":"compare/#cloud-comparisons","text":"There are a number of general methods to compare these popular cloud offerings without getting too specific that the documentation is always out of date.","title":"Cloud Comparisons"},{"location":"compare/#compare-cloud-development-tools","text":"","title":"Compare Cloud Development Tools"},{"location":"compare/#command-line-interface-cli","text":"All clouds offer a local installation as well as an online version.","title":"Command-Line Interface (CLI)"},{"location":"compare/#software-development-kit-sdk","text":"SDKs will vary based on the specific type of services, the preferred programming language, and style of cloud platform interaction. AWS Azure GCP Javascript, Python, PHP, .NET, Ruby, Java, Go, Node.js, C++ .NET, Java, JavaScript, Python, GO, C++, C, PHP, Ruby GCloud CLI Web, Native Mobile, Internet of Things (IoT), IDE extensions / plug-ins, Command-Line Internet of Things (IoT), Apple Native Mobile Google APIs","title":"Software Development Kit (SDK)"},{"location":"compare/#web-consoles","text":"Comparison AWS Azure GCP Service Name Management Console Portal Cloud Console","title":"Web Consoles"},{"location":"compare/#cloud-developer-tools","text":"Comparison AWS Azure GCP Service Name Cloud9 Visual Studio Code Cloud Code IDE Online Experience Yes Yes Yes Supports A variety of programming languages, real-time collaboration, container development, build, test, and debugging code Implements a comparable online version of VS Code Integrates into common developer tools","title":"Cloud Developer Tools"},{"location":"compare/#infrastructure-as-code","text":"Comparison AWS Azure GCP Service Name CloudFormation Azure Resource Manager (ARM) Templates Deployment Manager Language YAML JSON with Bicep (domain-specific language) YAML Terraform Yes Yes Yes","title":"Infrastructure as Code"},{"location":"compare/#local-developer-tools","text":"Ultimately, developers may choose to run any choice of local developer tools and all clouds support the ability to run the artifacts from all languages in some form (e.g. Serverless, PaaS, Containers, or IaaS).","title":"Local Developer Tools"},{"location":"compare/#developer-tool-resources","text":"Tool AWS Azure GCP Developer Tools AWS developer tools Azure developer tools GCP developer tools CLI AWS CLI Azure CLI GCP CLI SDKs AWS SDKs Azure SDKs Google Cloud SDK Management AWS Management Console Microsoft Azure Portal Google Cloud Console Developer Environments AWS Cloud9 Visual Studio Code Google Cloud Code IDE Infrastructure as Code AWS CloudFormation Azure Resource Manager Google Cloud Deployment Manager","title":"Developer Tool Resources"},{"location":"compare/#compare-cloud-storage","text":"","title":"Compare Cloud Storage"},{"location":"compare/#object-storage","text":"Comparison AWS Azure GCP Service Name Simple Storage Service (S3) BLOB Storage Cloud Storage Container Name Bucket Container Bucket Versioning, Encryption, Fine-grained security Yes Yes Yes Less frequently accessed data Infrequently accessed Cool BLOB Nearline, Coldline Archiving Glacier Archive Archive Lifecycle management Yes Yes Yes","title":"Object Storage"},{"location":"compare/#file-storage","text":"Comparison AWS Azure GCP Service Name Elastic File System (EFS) Amazon FSx for Windows Amazon FSx for Lustre Files Filestore","title":"File Storage"},{"location":"compare/#block-storage","text":"Great for virtual machines, this storage method provides high performance with high IOPS. Comparison AWS Azure GCP Service Name Elastic Block Storage (EBS) Azure Managed Disks Persistent disks & Solid-state disks Flexible storage type and IOPS provisioning Yes Yes Yes Scheduled and ad-hoc snapshots Yes Yes Yes","title":"Block Storage"},{"location":"compare/#data-transport","text":"While all clouds provide web interfaces and command-line tools for uploads, Azure and Amazon also offer localized data sync \"transfer gateways\" to upload. All clouds also offer hard drive data transfer by mail. Azure offers Data Box Disk with up to 40 TB and Azure Data Box Heavy up to 1 PB. Google Cloud offers their \"Transfer Appliance\" for up to 1 PB. The Amazon Web Services \"Snow Family\" has the most variety of physical transfer options including their \"Snowmobile\", a tractor trailer that can transfer up to 100 PB of data.","title":"Data Transport"},{"location":"compare/#more-comparisons","text":"Check out A Cloud Guru Cloud Comparison videos . Consider contributing more comparisons to this page.","title":"More comparisons..."},{"location":"contribute/","text":"Contributing Welcome and we are glad you are interested in contributing! Ways to contribute Discuss: post a comment at the bottom of every page Submit an issue Comment on an issue Star Watch Create a project Development ./docs The \"./docs\" folder is automatically generated output. Please make changes to \"./src/docs\". Adding a new project Is your favorite language and/or framework to build a website or web service missing from this project? What great ideas to you have to demonstrate getting systems to the cloud? A working program 1. The 'Hello World' program Check if the idea is already on the roadmap or has already been submitted as an issue . Submit an issue that describes your idea to start a discussion. Fork this project and clone it to your local system. Review the \"Development\" steps below. Review one of the existing projects for similarities to your idea. Create a new directory for your source code (e.g. \"./src/services/[language/framework]\" for web services or \"./src/apps/[language/framework]\" for web applications). Add a basic \"hello world\" example using the language and framework of choice. Commit small, working changes regularly and please use \"conventional commit messages\" . You can see existing examples of commit messages . Automate the developer tasks by creating a new \"./makefile\" in your project, copy command targets from an existing \"./makefile\" from another project and customize the commands to work with your language and framework. Ignore any deployment commands for now and also ignore command targets you are not ready or not sure how to implement. Commit your changes. Add the path to your project in the root \"./makefile\" in the space-separated \"project_dirs\" variable list. This will enable developers to build and run all projects at the same time, including yours. Commit your changes. Submit a PR request back to this project. Learn more about creating a pull request. We will start a discussion on the proposed implementation. Please be open to making any suggested changes. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>R: Check roadmap C->>R: Submit issue M->>R: Review issue M->>C: Discuss issue C->>R: Clone C->>C: Create new project C->>R: Submit \"draft\" PR loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Hello World 2. Containers Once you have a basic \"hello world\" example working, it's time to containerize your build and test workflow as well as the system deployment, so that it can be executed by any Open Container Initiative-compatible runtime across machines including locally by developers and DevOps pipeline automation. Review an existing \"./makefile\" from another project and customize your project's commands to work with docker , docker-compose and podman . Hopefully, a base docker image will already exist to mount and execute your application (e.g. node ). If so, use this as your base. If not, consider choosing Alpine Linux , Debian , or Ubuntu for your base image. Create a \"Dockerfile\" and test your container locally. Commit your changes. Update your existing Pull Request so that we can discuss the container work. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Containerize system C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Containers 3. Writing documentation Once you have a working container, it's time to start documenting your project. Copy and paste an existing project's markdown file from \"./src/docs/\" (e.g. ./src/docs/services/nodejs-expressjs.md). Review and edit the sections to match, customizing links and commands to match your project's needs. Delete any cloud deployment sections at this time. Commit your changes. Add links to your project documentation in \"./mkdocs.yml\" as well as \"./src/docs/index.md\" (both are under \"Projects\"). Commit your changes. Update your existing Pull Request so that we can discuss the documentation. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Document system C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Documentation 4. Integrating a DevOps pipeline Documentation for all projects will be automatically built through the \"documentation\" pipeline . However, we need to build and publish your project's docker container. Copy and paste an existing project's GitHub Actions pipeline workflow \".yml\" configuration from \"./.github/workflows/\". Customize the names and paths to match your project. It will not be possible to test this workflow. Commit your changes. Update your existing Pull Request so that we can discuss the workflow. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Create GitHub Actions workflow C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Container DevOps 5. Finalize PR Although your project has not even been deployed to a major cloud provider yet, the basic foundation now exists to integrate cloud automation tasks. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch, your project container will be built and published, and your project will be added to the public documentation. This now provides others with a chance to build on top of your project too. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository participant GHA as GitHub Actions participant GHPkg as GitHub Packages participant GHPages as GitHub Pages participant site as Ourchitecture.io loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end M->>R: Approve PR M->>R: Merge PR to \"main\" GHA->>GHPkg: Generate docker image GHA->>R: Generate documentation GHA->>R: Submit documentation PR M->>R: Approve and merge documentation PR GHPages->>R: Read \"./docs\" GHPages->>site: Update public documentation site Finalize PR Cloud deployments Once we have a working, containerized program, we can begin cloud deployment automation tasks. 1. Pick just one cloud Pick one of the major cloud providers that you will target a deployment for (e.g. AWS, Azure, GCP, or Heroku). If your cloud provider is not in this list, please first propose a new one by submitting an issue and we can discuss the proposal. Please understand that your request could be denied. You will need an account that may incur costs when testing your cloud deployment. Most \"hello world\" implementations are free or very cheap on major cloud providers, especially if you focus on automating destruction of cloud resources and destroy them immediately after creating them and testing for success. Review an existing project's cloud deployment documentation. Review an existing project's \"./makefile\" cloud deployment command targets. Begin work to add your own cloud deployment command targets to your project's \"./makefile\". Commit your changes. Begin to document the steps by copying and pasting the cloud section from an existing project and customizing as required. Commit your changes. Update your project's \"Roadmap\" section with what has been completed and possible next steps. Commit your changes. Submit another \"draft pull request\" back to this project to start the discussion on your cloud deployment tasks. Please be open to making any suggested changes. 2. Finalize PR We will work to test the cloud deployment. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch and your project's cloud deployment documentation will be updated in the public documentation. 3. Enhance, enhance, enhance As you did in the first step, you and even others may continue to enhance this great project! Development This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against. Development resources Submit an issue Comment on an issue Star Watch Fork Prerequisites Windows users Task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH with make for Git BASH installed or cygwin with make for cygwin installed. You could also use a Linux virtual machine running on Windows Hyper-V , Oracle VirtualBox , or even using a VS Code \"devcontainer\" . Tools Avoid Global installations of gradle or maven are not needed or recommended. The Java and Kotlin projects use Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines. Required git for source control. docker , docker-compose , or podman are required to build the documentation and production container images. Recommended GNU make is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above ) Optional... yarn or node are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK is required to run Java and Kotlin projects. However, container runtimes make this installation optional. dotnet 6 SDK is required to run .NET projects. However, container runtimes make this installation optional. VS code may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town may be used for improved developer workflow. Executing tasks Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker ; while this project would prefer to use a completely free and open source ecosystem like podman , docker is a well established project, virtually ubiquitous on most local and DevOps machines, and mostly free . Commands that work across all projects All automation tasks are abstracted behind make command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java and Kotlin projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default \"dev_tool\", since it is also used by DevOps pipeline tasks for production build, test, and deploy. Clone the repository with the command git clone --depth=1 https://github.com/ourchitecture/hello-cloud ( SalesForce Heroku rejects pushes from shallow clones , so remove the --depth=1 argument) Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Cmd + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work) Using locally installed tools... If you do not wish to use make , review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work. # instead of using make across all projects # and not needing to know specific tools or their arguments # and even forgetting exactly which command to use # among other synonym alternatives... # example: $ make start # or make [start,run,up,serve] # and, instead of running make with a variety of tooling choices... # examples: $ make start dev_tool = podman $ make start dev_tool = docker $ make start dev_tool = docker-compose $ make start dev_tool = node $ make start dev_tool = npm $ make start dev_tool = yarn $ make start dev_tool = gradle $ make start dev_tool = gradlew $ make start dev_tool = maven $ make start dev_tool = mvn $ make start dev_tool = mvnw $ make start dev_tool = dotnet # ... you can use the tools themselves directly # this is especially useful for getting things working # however, once things are working, # it's great to go back and re-test the make commands # to ensure consistent command definitions and execution # across machines (developers and DevOps pipelines) # run a NodeJS project with native commands # (may have project-specific arguments) $ npm install && npm start $ yarn && yarn start # run a Java or Kotlin project with native commands # (may have project-specific arguments) $ ./gradlew bootRun $ ./mvnw spring-boot:run # run a .NET Core project with native commands # (may have project-specific arguments) $ dotnet run Maintainers Project maintainers serve as leading contributors to the project's vision and development and are responsible for developing and supporting the project community as a whole. Monitor and review pull requests at least weekly Monitor and review issues at least weekly Monitor and review pipelines at least weekly Moderate Disqus comments Occassionally, run make check-versions , review the logs and search for opportunities to upgrade the versions (e.g. docker image versions, OS middleware versions, programming language and framework versions, code package dependency versions, etc.) Occassionally, review the site Occassionally, follow the \"Contributor guidelines\" and tutorials from scratch; delete any previously cloned local repository Docker images New docker images should appear in the list of \"packages\" . However, the first time a docker package is built, it does not seem to be properly associated with the \"hello-cloud\" repository, does not have \"Write\" permissions for GitHub Actions and is not listed as \"Public\" for others to see. Find the docker package by reviewing the GitHub Actions build output for the docker image URL and visit the URL. e.g. ghcr.io/ourchitecture/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Ensure the package is associated with the \"hello-cloud\" repository and that the \"./README.md\" appears in the package. Edit the \"Package settings\" for the package Manage Actions access Ensure that the \"hello-cloud\" repository has \"Write\" permissions under \"Manage Actions access\" Check that \"Change package visibility\" is set to \"Public\"","title":"Contribute"},{"location":"contribute/#contributing","text":"Welcome and we are glad you are interested in contributing! Ways to contribute Discuss: post a comment at the bottom of every page Submit an issue Comment on an issue Star Watch Create a project Development ./docs The \"./docs\" folder is automatically generated output. Please make changes to \"./src/docs\".","title":"Contributing"},{"location":"contribute/#adding-a-new-project","text":"Is your favorite language and/or framework to build a website or web service missing from this project? What great ideas to you have to demonstrate getting systems to the cloud?","title":"Adding a new project"},{"location":"contribute/#a-working-program","text":"1. The 'Hello World' program Check if the idea is already on the roadmap or has already been submitted as an issue . Submit an issue that describes your idea to start a discussion. Fork this project and clone it to your local system. Review the \"Development\" steps below. Review one of the existing projects for similarities to your idea. Create a new directory for your source code (e.g. \"./src/services/[language/framework]\" for web services or \"./src/apps/[language/framework]\" for web applications). Add a basic \"hello world\" example using the language and framework of choice. Commit small, working changes regularly and please use \"conventional commit messages\" . You can see existing examples of commit messages . Automate the developer tasks by creating a new \"./makefile\" in your project, copy command targets from an existing \"./makefile\" from another project and customize the commands to work with your language and framework. Ignore any deployment commands for now and also ignore command targets you are not ready or not sure how to implement. Commit your changes. Add the path to your project in the root \"./makefile\" in the space-separated \"project_dirs\" variable list. This will enable developers to build and run all projects at the same time, including yours. Commit your changes. Submit a PR request back to this project. Learn more about creating a pull request. We will start a discussion on the proposed implementation. Please be open to making any suggested changes. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>R: Check roadmap C->>R: Submit issue M->>R: Review issue M->>C: Discuss issue C->>R: Clone C->>C: Create new project C->>R: Submit \"draft\" PR loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Hello World 2. Containers Once you have a basic \"hello world\" example working, it's time to containerize your build and test workflow as well as the system deployment, so that it can be executed by any Open Container Initiative-compatible runtime across machines including locally by developers and DevOps pipeline automation. Review an existing \"./makefile\" from another project and customize your project's commands to work with docker , docker-compose and podman . Hopefully, a base docker image will already exist to mount and execute your application (e.g. node ). If so, use this as your base. If not, consider choosing Alpine Linux , Debian , or Ubuntu for your base image. Create a \"Dockerfile\" and test your container locally. Commit your changes. Update your existing Pull Request so that we can discuss the container work. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Containerize system C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Containers 3. Writing documentation Once you have a working container, it's time to start documenting your project. Copy and paste an existing project's markdown file from \"./src/docs/\" (e.g. ./src/docs/services/nodejs-expressjs.md). Review and edit the sections to match, customizing links and commands to match your project's needs. Delete any cloud deployment sections at this time. Commit your changes. Add links to your project documentation in \"./mkdocs.yml\" as well as \"./src/docs/index.md\" (both are under \"Projects\"). Commit your changes. Update your existing Pull Request so that we can discuss the documentation. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Document system C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Documentation 4. Integrating a DevOps pipeline Documentation for all projects will be automatically built through the \"documentation\" pipeline . However, we need to build and publish your project's docker container. Copy and paste an existing project's GitHub Actions pipeline workflow \".yml\" configuration from \"./.github/workflows/\". Customize the names and paths to match your project. It will not be possible to test this workflow. Commit your changes. Update your existing Pull Request so that we can discuss the workflow. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository C->>C: Create GitHub Actions workflow C->>R: Push changes loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end Container DevOps 5. Finalize PR Although your project has not even been deployed to a major cloud provider yet, the basic foundation now exists to integrate cloud automation tasks. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch, your project container will be built and published, and your project will be added to the public documentation. This now provides others with a chance to build on top of your project too. sequenceDiagram participant C as Contributor participant M as Maintainer participant R as Repository participant GHA as GitHub Actions participant GHPkg as GitHub Packages participant GHPages as GitHub Pages participant site as Ourchitecture.io loop PR Review M->>R: Review PR M->>C: Discuss PR C->>C: Make any changes C->>R: Push changes end M->>R: Approve PR M->>R: Merge PR to \"main\" GHA->>GHPkg: Generate docker image GHA->>R: Generate documentation GHA->>R: Submit documentation PR M->>R: Approve and merge documentation PR GHPages->>R: Read \"./docs\" GHPages->>site: Update public documentation site Finalize PR","title":"A working program"},{"location":"contribute/#cloud-deployments","text":"Once we have a working, containerized program, we can begin cloud deployment automation tasks. 1. Pick just one cloud Pick one of the major cloud providers that you will target a deployment for (e.g. AWS, Azure, GCP, or Heroku). If your cloud provider is not in this list, please first propose a new one by submitting an issue and we can discuss the proposal. Please understand that your request could be denied. You will need an account that may incur costs when testing your cloud deployment. Most \"hello world\" implementations are free or very cheap on major cloud providers, especially if you focus on automating destruction of cloud resources and destroy them immediately after creating them and testing for success. Review an existing project's cloud deployment documentation. Review an existing project's \"./makefile\" cloud deployment command targets. Begin work to add your own cloud deployment command targets to your project's \"./makefile\". Commit your changes. Begin to document the steps by copying and pasting the cloud section from an existing project and customizing as required. Commit your changes. Update your project's \"Roadmap\" section with what has been completed and possible next steps. Commit your changes. Submit another \"draft pull request\" back to this project to start the discussion on your cloud deployment tasks. Please be open to making any suggested changes. 2. Finalize PR We will work to test the cloud deployment. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch and your project's cloud deployment documentation will be updated in the public documentation. 3. Enhance, enhance, enhance As you did in the first step, you and even others may continue to enhance this great project!","title":"Cloud deployments"},{"location":"contribute/#development","text":"This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against. Development resources Submit an issue Comment on an issue Star Watch Fork","title":"Development"},{"location":"contribute/#prerequisites","text":"Windows users Task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH with make for Git BASH installed or cygwin with make for cygwin installed. You could also use a Linux virtual machine running on Windows Hyper-V , Oracle VirtualBox , or even using a VS Code \"devcontainer\" .","title":"Prerequisites"},{"location":"contribute/#tools","text":"Avoid Global installations of gradle or maven are not needed or recommended. The Java and Kotlin projects use Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines. Required git for source control. docker , docker-compose , or podman are required to build the documentation and production container images. Recommended GNU make is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above ) Optional... yarn or node are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK is required to run Java and Kotlin projects. However, container runtimes make this installation optional. dotnet 6 SDK is required to run .NET projects. However, container runtimes make this installation optional. VS code may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town may be used for improved developer workflow.","title":"Tools"},{"location":"contribute/#executing-tasks","text":"Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker ; while this project would prefer to use a completely free and open source ecosystem like podman , docker is a well established project, virtually ubiquitous on most local and DevOps machines, and mostly free . Commands that work across all projects All automation tasks are abstracted behind make command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java and Kotlin projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default \"dev_tool\", since it is also used by DevOps pipeline tasks for production build, test, and deploy. Clone the repository with the command git clone --depth=1 https://github.com/ourchitecture/hello-cloud ( SalesForce Heroku rejects pushes from shallow clones , so remove the --depth=1 argument) Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Cmd + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work) Using locally installed tools... If you do not wish to use make , review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work. # instead of using make across all projects # and not needing to know specific tools or their arguments # and even forgetting exactly which command to use # among other synonym alternatives... # example: $ make start # or make [start,run,up,serve] # and, instead of running make with a variety of tooling choices... # examples: $ make start dev_tool = podman $ make start dev_tool = docker $ make start dev_tool = docker-compose $ make start dev_tool = node $ make start dev_tool = npm $ make start dev_tool = yarn $ make start dev_tool = gradle $ make start dev_tool = gradlew $ make start dev_tool = maven $ make start dev_tool = mvn $ make start dev_tool = mvnw $ make start dev_tool = dotnet # ... you can use the tools themselves directly # this is especially useful for getting things working # however, once things are working, # it's great to go back and re-test the make commands # to ensure consistent command definitions and execution # across machines (developers and DevOps pipelines) # run a NodeJS project with native commands # (may have project-specific arguments) $ npm install && npm start $ yarn && yarn start # run a Java or Kotlin project with native commands # (may have project-specific arguments) $ ./gradlew bootRun $ ./mvnw spring-boot:run # run a .NET Core project with native commands # (may have project-specific arguments) $ dotnet run","title":"Executing tasks"},{"location":"contribute/#maintainers","text":"Project maintainers serve as leading contributors to the project's vision and development and are responsible for developing and supporting the project community as a whole. Monitor and review pull requests at least weekly Monitor and review issues at least weekly Monitor and review pipelines at least weekly Moderate Disqus comments Occassionally, run make check-versions , review the logs and search for opportunities to upgrade the versions (e.g. docker image versions, OS middleware versions, programming language and framework versions, code package dependency versions, etc.) Occassionally, review the site Occassionally, follow the \"Contributor guidelines\" and tutorials from scratch; delete any previously cloned local repository","title":"Maintainers"},{"location":"contribute/#docker-images","text":"New docker images should appear in the list of \"packages\" . However, the first time a docker package is built, it does not seem to be properly associated with the \"hello-cloud\" repository, does not have \"Write\" permissions for GitHub Actions and is not listed as \"Public\" for others to see. Find the docker package by reviewing the GitHub Actions build output for the docker image URL and visit the URL. e.g. ghcr.io/ourchitecture/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Ensure the package is associated with the \"hello-cloud\" repository and that the \"./README.md\" appears in the package. Edit the \"Package settings\" for the package Manage Actions access Ensure that the \"hello-cloud\" repository has \"Write\" permissions under \"Manage Actions access\" Check that \"Change package visibility\" is set to \"Public\"","title":"Docker images"},{"location":"devops/","text":"DevOps Local development See the contributor guide for local development. Pipelines Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" . Documentation Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs , Material for MkDocs , and the \"mkdocs-material\" dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"DevOps"},{"location":"devops/#devops","text":"","title":" DevOps"},{"location":"devops/#local-development","text":"See the contributor guide for local development.","title":"Local development"},{"location":"devops/#pipelines","text":"Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" .","title":" Pipelines"},{"location":"devops/#documentation","text":"Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs , Material for MkDocs , and the \"mkdocs-material\" dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"Documentation"},{"location":"license/","text":"License The Free Stuff Everything except \"Restrictive Licensing\" below in the project falls under \"Creative Commons Zero v1.0 Universal\"; that is, completely free. You are free to use the code and documentation without concern or even attribution. Restrictive Licensing Some content may use external images, contain quotes or linked references to content external to the \"hello-world\" project. This content retains its original licensing restrictions and copyright. Everything in the directories \"./src/docs/assets/images\", \"./src/docs/img\" and \"./src/media/\" may contain restrictive licensing. Media contained in these directories may have stricter licensing restrictions. Read the unique licensing concerns listed below... \"logo.svg\", \"logo.png\", and \"favicon.png\" may not be redistributed and are licensed to Eric Swanson from thenounproject.com Open Source This project is entirely based on open source implementations that ultimately target deployments to proprietary clouds. While there are many open source projects used throughout this project, we have received the biggest help from the following projects: .NET Core Alpine Linux Debian Docker ExpressJS GNU make Java OpenJDK Java Spring MkDocs Material for MkDocs mermaid NodeJS podman Ubuntu","title":"License"},{"location":"license/#license","text":"The Free Stuff Everything except \"Restrictive Licensing\" below in the project falls under \"Creative Commons Zero v1.0 Universal\"; that is, completely free. You are free to use the code and documentation without concern or even attribution. Restrictive Licensing Some content may use external images, contain quotes or linked references to content external to the \"hello-world\" project. This content retains its original licensing restrictions and copyright. Everything in the directories \"./src/docs/assets/images\", \"./src/docs/img\" and \"./src/media/\" may contain restrictive licensing. Media contained in these directories may have stricter licensing restrictions. Read the unique licensing concerns listed below... \"logo.svg\", \"logo.png\", and \"favicon.png\" may not be redistributed and are licensed to Eric Swanson from thenounproject.com Open Source This project is entirely based on open source implementations that ultimately target deployments to proprietary clouds. While there are many open source projects used throughout this project, we have received the biggest help from the following projects: .NET Core Alpine Linux Debian Docker ExpressJS GNU make Java OpenJDK Java Spring MkDocs Material for MkDocs mermaid NodeJS podman Ubuntu","title":"License"},{"location":"roadmap/","text":"Roadmap Documentation Project overview Cloud for Business Cloud for Technology Leaders Cloud for Technology Designers (e.g. architecture) Cloud for Developers Clouds Amazon Web Services Functions: Lambda PaaS: Elastic Beanstalk Managed Containers: Elastic Beanstalk Managed Kubernetes: Elastic Kubernetes Service (EKS) Google Cloud Functions: Google Functions PaaS: AppEngine Managed Containers: AppEngine Managed Kubernetes: Google Kubernetes Engine (GKE) Microsoft Azure Functions: Azure Functions PaaS: AppService Managed Containers: AppService Managed Containers: Azure Container Instance (ACI) Managed Kubernetes: Azure Kubernetes Service (AKS) Salesforce Heroku PaaS Deployments PaaS Managed Containers (no Kubernetes) Managed Kubernetes Services Languages and Frameworks .NET Core C# Go Java with SpringBoot Kotlin with SpringBoot NodeJS with ExpressJS Python Rust Contracts AsyncAPI GraphQL gRPC OpenAPI Web Applications Angular Ionic with StencilJS Next.js React Vue.js DevOps Build and deploy documentation with MkDocs as GitHub Pages Build and push docker containers Build and test each project Automated project deployment (infrastructure and code; create, test and destroy) Service contract documentation integration (i.e. generate service documentation and integrate with MkDocs) Developer Features Cross-platform support Consistent task execution with GNU make Containerized task execution with docker , docker-compose , and podman Containerized cloud tooling (e.g. aws and eb , az , gcloud ) Containerized development environment Native tool support e.g. node , yarn and npm ; gradle ( ./gradlew ) and maven ( ./mvnw ); dotnet Consistent development with \"./.editorconfig\" Consistent styles with Prettier Automated documentation with MkDocs and GitHub Actions CI/CD workflows with GitHub Actions Docker deployment with GitHub Packages and GitHub Container Registry Shared VS Code settings and recommended extensions VS Code project workspaces Project Roadmaps .NET Service Roadmap Java with SpringBoot Service Roadmap Kotlin with SpringBoot Service Roadmap NodeJS with ExpressJS Service Roadmap","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Documentation Project overview Cloud for Business Cloud for Technology Leaders Cloud for Technology Designers (e.g. architecture) Cloud for Developers Clouds Amazon Web Services Functions: Lambda PaaS: Elastic Beanstalk Managed Containers: Elastic Beanstalk Managed Kubernetes: Elastic Kubernetes Service (EKS) Google Cloud Functions: Google Functions PaaS: AppEngine Managed Containers: AppEngine Managed Kubernetes: Google Kubernetes Engine (GKE) Microsoft Azure Functions: Azure Functions PaaS: AppService Managed Containers: AppService Managed Containers: Azure Container Instance (ACI) Managed Kubernetes: Azure Kubernetes Service (AKS) Salesforce Heroku PaaS Deployments PaaS Managed Containers (no Kubernetes) Managed Kubernetes Services Languages and Frameworks .NET Core C# Go Java with SpringBoot Kotlin with SpringBoot NodeJS with ExpressJS Python Rust Contracts AsyncAPI GraphQL gRPC OpenAPI Web Applications Angular Ionic with StencilJS Next.js React Vue.js DevOps Build and deploy documentation with MkDocs as GitHub Pages Build and push docker containers Build and test each project Automated project deployment (infrastructure and code; create, test and destroy) Service contract documentation integration (i.e. generate service documentation and integrate with MkDocs) Developer Features Cross-platform support Consistent task execution with GNU make Containerized task execution with docker , docker-compose , and podman Containerized cloud tooling (e.g. aws and eb , az , gcloud ) Containerized development environment Native tool support e.g. node , yarn and npm ; gradle ( ./gradlew ) and maven ( ./mvnw ); dotnet Consistent development with \"./.editorconfig\" Consistent styles with Prettier Automated documentation with MkDocs and GitHub Actions CI/CD workflows with GitHub Actions Docker deployment with GitHub Packages and GitHub Container Registry Shared VS Code settings and recommended extensions VS Code project workspaces Project Roadmaps .NET Service Roadmap Java with SpringBoot Service Roadmap Kotlin with SpringBoot Service Roadmap NodeJS with ExpressJS Service Roadmap","title":"Roadmap"},{"location":"services/dotnet/","text":"Service: .NET Core Container: hello-cloud/our-hello-dotnet-webapi Source: ./src/services/dotnet/webapi/ Runtime: .NET Core Language: C# Framework: ASP.NET Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container, Amazon Web Services AppRunner, Microsoft Azure App Service, Google Cloud App Engine Deployments Docker Run as a container The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:5124/ . docker run \\ --name = our-hello-dotnet-webapi \\ --detach \\ --publish = 5124 :80 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-dotnet-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/dotnet_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites See the contributor guide for more details. An AWS account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Copy the \"./deploy/aws/.env.example\" file and save it as a new file \"./deploy/aws/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/aws/.env\" and replace the values according to preferences. If required, for the values \"AWS_ACCESS_KEY_ID\" and \"AWS_SECRET_ACCESS_KEY\", create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Run the command make install cloud=aws to create the AWS Elastic Beanstalk Environment and install the application. This command may take a few minutes. Update the application with the same command make install cloud=aws . Check the application logs with the command make logs cloud=aws Uninstall and clean up the application deployment with the command make uninstall cloud=aws . This command may take several seconds. Microsoft Azure Prerequisites See the contributor guide for more details. An Azure account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/azure/.env.example\" file and save it as a new file \"./deploy/azure/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/azure/.env\" and replace the values according to preferences. If required, for the values \"AZURE_SP_APPID\", \"AZURE_SP_PASSWORD\", and \"AZURE_SP_TENANT\", create new service principal credentials with the Azure CLI and the command az ad sp create-for-rbac --name \"our-hello-sp\" --role Contributor , providing any --name as desired. *You may encounter an error with multiple subscriptions as this has not been tested. Consider a contribution . Run the command make install cloud=azure to create the Azure Resource Group, Azure AppService Plan, and AppService if they do not exist as well as to deploy the application. Check the application logs with the command make logs cloud=azure Uninstall and clean up the application deployment with the command make uninstall cloud=azure Google Cloud Prerequisites See the contributor guide for more details. A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud Billing Account Once a project is created, you may be prompted to enable Google Cloud Build git for source control. GNU make for standard task execution. docker for containerized task execution. Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as with manually associating dynamically created projects with a billing account and enabling services like \"Cloud Build\", \"Cloud Run\", and \"Artifact Registry\". Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/gcloud/.env.example\" file and save it as a new file \"./deploy/gcloud/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/gcloud/.env\" and replace the values according to preferences. Run the command make install cloud=gcloud to create a new Google Cloud project, application, and deploy the code. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) If the output indicates that any of the services including \"Cloud Build\", \"Cloud Run\", or \"Artifact Registry\" must be enabled, login to the projects list and enable the missing API Check the application logs with the command make logs cloud=gcloud Uninstall and clean up the application deployment with the command make uninstall cloud=gcloud Tip: Project Naming Google Cloud retains deleted projects for a time. If the value for \"GCLOUD_PROJECT_ID\" in \"./deploy/gcloud/.env\" already exists as an active project, nothing will be done. If the project has been deleted, the project will be restored. If the project does not exist, it will be created. SalesForce Heroku Prerequisites See the contributor guide for more details. A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/heroku/.env.example\" file and save it as a new file \"./deploy/heroku/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/heroku/.env\" and replace the values according to preferences. Run the command make install cloud=heroku to create a new Heroku application and deploy the code. Check the application logs with the command make logs cloud=heroku Uninstall and clean up the application deployment with the command make uninstall cloud=heroku Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"azure\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( dotnet ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" requires a container \"azure\" \"gcloud\" quirky. AppEngine had some challenges, but got Cloud Run working. \"heroku\" requires a community buildpack Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"gcloud\"","title":".NET"},{"location":"services/dotnet/#service-net-core","text":"Container: hello-cloud/our-hello-dotnet-webapi Source: ./src/services/dotnet/webapi/ Runtime: .NET Core Language: C# Framework: ASP.NET","title":"Service: .NET Core"},{"location":"services/dotnet/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/dotnet/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container, Amazon Web Services AppRunner, Microsoft Azure App Service, Google Cloud App Engine","title":" DevOps"},{"location":"services/dotnet/#deployments","text":"","title":"Deployments"},{"location":"services/dotnet/#docker","text":"Run as a container The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:5124/ . docker run \\ --name = our-hello-dotnet-webapi \\ --detach \\ --publish = 5124 :80 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-dotnet-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/dotnet_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image .","title":" Docker"},{"location":"services/dotnet/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/dotnet/#amazon-web-services-aws","text":"Prerequisites See the contributor guide for more details. An AWS account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Copy the \"./deploy/aws/.env.example\" file and save it as a new file \"./deploy/aws/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/aws/.env\" and replace the values according to preferences. If required, for the values \"AWS_ACCESS_KEY_ID\" and \"AWS_SECRET_ACCESS_KEY\", create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Run the command make install cloud=aws to create the AWS Elastic Beanstalk Environment and install the application. This command may take a few minutes. Update the application with the same command make install cloud=aws . Check the application logs with the command make logs cloud=aws Uninstall and clean up the application deployment with the command make uninstall cloud=aws . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/dotnet/#microsoft-azure","text":"Prerequisites See the contributor guide for more details. An Azure account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/azure/.env.example\" file and save it as a new file \"./deploy/azure/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/azure/.env\" and replace the values according to preferences. If required, for the values \"AZURE_SP_APPID\", \"AZURE_SP_PASSWORD\", and \"AZURE_SP_TENANT\", create new service principal credentials with the Azure CLI and the command az ad sp create-for-rbac --name \"our-hello-sp\" --role Contributor , providing any --name as desired. *You may encounter an error with multiple subscriptions as this has not been tested. Consider a contribution . Run the command make install cloud=azure to create the Azure Resource Group, Azure AppService Plan, and AppService if they do not exist as well as to deploy the application. Check the application logs with the command make logs cloud=azure Uninstall and clean up the application deployment with the command make uninstall cloud=azure","title":" Microsoft Azure"},{"location":"services/dotnet/#google-cloud","text":"Prerequisites See the contributor guide for more details. A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud Billing Account Once a project is created, you may be prompted to enable Google Cloud Build git for source control. GNU make for standard task execution. docker for containerized task execution. Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as with manually associating dynamically created projects with a billing account and enabling services like \"Cloud Build\", \"Cloud Run\", and \"Artifact Registry\". Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/gcloud/.env.example\" file and save it as a new file \"./deploy/gcloud/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/gcloud/.env\" and replace the values according to preferences. Run the command make install cloud=gcloud to create a new Google Cloud project, application, and deploy the code. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) If the output indicates that any of the services including \"Cloud Build\", \"Cloud Run\", or \"Artifact Registry\" must be enabled, login to the projects list and enable the missing API Check the application logs with the command make logs cloud=gcloud Uninstall and clean up the application deployment with the command make uninstall cloud=gcloud Tip: Project Naming Google Cloud retains deleted projects for a time. If the value for \"GCLOUD_PROJECT_ID\" in \"./deploy/gcloud/.env\" already exists as an active project, nothing will be done. If the project has been deleted, the project will be restored. If the project does not exist, it will be created.","title":" Google Cloud"},{"location":"services/dotnet/#salesforce-heroku","text":"Prerequisites See the contributor guide for more details. A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Copy the \"./deploy/heroku/.env.example\" file and save it as a new file \"./deploy/heroku/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/heroku/.env\" and replace the values according to preferences. Run the command make install cloud=heroku to create a new Heroku application and deploy the code. Check the application logs with the command make logs cloud=heroku Uninstall and clean up the application deployment with the command make uninstall cloud=heroku","title":" SalesForce Heroku"},{"location":"services/dotnet/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"azure\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( dotnet ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" requires a container \"azure\" \"gcloud\" quirky. AppEngine had some challenges, but got Cloud Run working. \"heroku\" requires a community buildpack Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"gcloud\"","title":"Roadmap"},{"location":"services/java-springboot/","text":"Service: Java with SpringBoot Container: \"hello-cloud/our-hello-java-springboot-webapi\" Source: ./src/services/jvm/java/springboot/webapi/ Runtime: OpenJDK Language: Java Framework: SpringBoot Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/jvm/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker Run as a container The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-java-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-java-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\" Troubleshooting Amazon Web Services Running the command make aws-install dev_tool=gradle may result in the error below. If it does, simply re-run the command. ERROR: InvalidParameterValueError - Environment named env-our-hello-kotlin-springboot is in an invalid state for this operation. Must be Ready. Microsoft Azure Running the command make azure-install dev_tool=maven may result in the error below and often successfully completes the deployment. If the deployment fails, simply check your network connection and re-run the command. The connection observed an error java.util.concurrent.TimeoutException: Channel write operation timed out Last write attempt timed out; force-closing the connection.","title":"Java with SpringBoot"},{"location":"services/java-springboot/#service-java-with-springboot","text":"Container: \"hello-cloud/our-hello-java-springboot-webapi\" Source: ./src/services/jvm/java/springboot/webapi/ Runtime: OpenJDK Language: Java Framework: SpringBoot","title":"Service: Java with SpringBoot"},{"location":"services/java-springboot/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/java-springboot/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/jvm/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":" DevOps"},{"location":"services/java-springboot/#deployments","text":"","title":"Deployments"},{"location":"services/java-springboot/#docker","text":"Run as a container The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-java-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-java-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image .","title":" Docker"},{"location":"services/java-springboot/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/java-springboot/#amazon-web-services-aws","text":"Prerequisites An AWS account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/java-springboot/#microsoft-azure","text":"Prerequisites An Azure account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":" Microsoft Azure"},{"location":"services/java-springboot/#google-cloud","text":"Prerequisites A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":" Google Cloud"},{"location":"services/java-springboot/#salesforce-heroku","text":"Prerequisites A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":" SalesForce Heroku"},{"location":"services/java-springboot/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Roadmap"},{"location":"services/java-springboot/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"services/java-springboot/#amazon-web-services","text":"Running the command make aws-install dev_tool=gradle may result in the error below. If it does, simply re-run the command. ERROR: InvalidParameterValueError - Environment named env-our-hello-kotlin-springboot is in an invalid state for this operation. Must be Ready.","title":" Amazon Web Services"},{"location":"services/java-springboot/#microsoft-azure_1","text":"Running the command make azure-install dev_tool=maven may result in the error below and often successfully completes the deployment. If the deployment fails, simply check your network connection and re-run the command. The connection observed an error java.util.concurrent.TimeoutException: Channel write operation timed out Last write attempt timed out; force-closing the connection.","title":" Microsoft Azure"},{"location":"services/kotlin-springboot/","text":"Service: Kotlin with SpringBoot Container: \"hello-cloud/our-hello-kotlin-springboot-webapi\" Source: ./src/services/jvm/kotlin/springboot/webapi/ Runtime: OpenJDK Language: Kotlin Framework: SpringBoot Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/kotlin_springboot_webapi.yml\" Source: \"./src/services/jvm/kotlin/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-kotlin-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker Run as a container The \"hello-cloud/our-hello-kotlin-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-kotlin-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-kotlin-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/kotlin_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-kotlin-springboot-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Kotlin SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Kotlin buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\" Troubleshooting Amazon Web Services Running the command make aws-install dev_tool=gradle may result in the error below. If it does, simply re-run the command. ERROR: InvalidParameterValueError - Environment named env-our-hello-kotlin-springboot is in an invalid state for this operation. Must be Ready. Microsoft Azure Running the command make azure-install dev_tool=maven may result in the error below and often successfully completes the deployment. If the deployment fails, simply check your network connection and re-run the command. The connection observed an error java.util.concurrent.TimeoutException: Channel write operation timed out Last write attempt timed out; force-closing the connection.","title":"Kotlin with SpringBoot"},{"location":"services/kotlin-springboot/#service-kotlin-with-springboot","text":"Container: \"hello-cloud/our-hello-kotlin-springboot-webapi\" Source: ./src/services/jvm/kotlin/springboot/webapi/ Runtime: OpenJDK Language: Kotlin Framework: SpringBoot","title":"Service: Kotlin with SpringBoot"},{"location":"services/kotlin-springboot/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/kotlin-springboot/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/kotlin_springboot_webapi.yml\" Source: \"./src/services/jvm/kotlin/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-kotlin-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":" DevOps"},{"location":"services/kotlin-springboot/#deployments","text":"","title":"Deployments"},{"location":"services/kotlin-springboot/#docker","text":"Run as a container The \"hello-cloud/our-hello-kotlin-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-kotlin-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-kotlin-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/kotlin_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-kotlin-springboot-webapi\" image .","title":" Docker"},{"location":"services/kotlin-springboot/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/kotlin-springboot/#amazon-web-services-aws","text":"Prerequisites An AWS account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/kotlin-springboot/#microsoft-azure","text":"Prerequisites An Azure account ( this project worked with fairly cheap or entirely free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":" Microsoft Azure"},{"location":"services/kotlin-springboot/#google-cloud","text":"Prerequisites A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Kotlin SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":" Google Cloud"},{"location":"services/kotlin-springboot/#salesforce-heroku","text":"Prerequisites A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/jvm/kotlin/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Kotlin buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":" SalesForce Heroku"},{"location":"services/kotlin-springboot/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Roadmap"},{"location":"services/kotlin-springboot/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"services/kotlin-springboot/#amazon-web-services","text":"Running the command make aws-install dev_tool=gradle may result in the error below. If it does, simply re-run the command. ERROR: InvalidParameterValueError - Environment named env-our-hello-kotlin-springboot is in an invalid state for this operation. Must be Ready.","title":" Amazon Web Services"},{"location":"services/kotlin-springboot/#microsoft-azure_1","text":"Running the command make azure-install dev_tool=maven may result in the error below and often successfully completes the deployment. If the deployment fails, simply check your network connection and re-run the command. The connection observed an error java.util.concurrent.TimeoutException: Channel write operation timed out Last write attempt timed out; force-closing the connection.","title":" Microsoft Azure"},{"location":"services/nodejs-expressjs/","text":"Service: NodeJS with ExpressJS Container: \"hello-cloud/our-hello-nodejs-expressjs-webapi\" Source: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS Language: JavaScript Framework: ExpressJS Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker Run as a container The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:3000/ . docker run \\ --name = our-hello-nodejs-expressjs-webapi \\ --detach \\ --publish = 3000 :3000 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make install cloud=aws ) Initialize and install (deploy) with the command make install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites See the contributor guide for more details. An AWS account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/aws/.env.example\" file and save it as a new file \"./deploy/aws/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/aws/.env\" and replace the values according to preferences. If required, for the values \"AWS_ACCESS_KEY_ID\" and \"AWS_SECRET_ACCESS_KEY\", create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Run the command make install cloud=aws to create the AWS Elastic Beanstalk Environment and install the application. This command may take a few minutes. Update the application with the same command make install cloud=aws . Check the application logs with the command make logs cloud=aws Uninstall and clean up the application deployment with the command make uninstall cloud=aws . This command may take several seconds. Microsoft Azure Prerequisites See the contributor guide for more details. An Azure account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/azure/.env.example\" file and save it as a new file \"./deploy/azure/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/azure/.env\" and replace the values according to preferences. If required, for the values \"AZURE_SP_APPID\", \"AZURE_SP_PASSWORD\", and \"AZURE_SP_TENANT\", create new service principal credentials with the Azure CLI and the command az ad sp create-for-rbac --name \"our-hello-sp\" --role Contributor , providing any --name as desired. *You may encounter an error with multiple subscriptions as this has not been tested. Consider a contribution . Run the command make install cloud=azure to create the Azure Resource Group, Azure AppService Plan, and AppService if they do not exist as well as to deploy the application. Check the application logs with the command make logs cloud=azure Uninstall and clean up the application deployment with the command make uninstall cloud=azure Google Cloud Prerequisites See the contributor guide for more details. A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud Billing Account Once a project is created, you will be prompted to enable Google Cloud Build git for source control. GNU make for standard task execution. docker for containerized task execution. Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Cloud Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/gcloud/.env.example\" file and save it as a new file \"./deploy/gcloud/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/gcloud/.env\" and replace the values according to preferences. Run the command make install cloud=gcloud to create a new Google Cloud project, application, and deploy the code. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) If the output indicates that \"Cloud Build\" must be enabled, login to the projects list and enable the cloud build API Check the application logs with the command make logs cloud=gcloud Uninstall and clean up the application deployment with the command make uninstall cloud=gcloud Tip: Project Naming Google Cloud retains deleted projects for a time. If the value for \"GCLOUD_PROJECT_ID\" in \"./deploy/gcloud/.env\" already exists as an active project, nothing will be done. If the project has been deleted, the project will be restored. If the project does not exist, it will be created. SalesForce Heroku Prerequisites See the contributor guide for more details. A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/heroku/.env.example\" file and save it as a new file \"./deploy/heroku/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/heroku/.env\" and replace the values according to preferences. Run the command make install cloud=heroku to create a new Heroku application and deploy the code. Check the application logs with the command make logs cloud=heroku Uninstall and clean up the application deployment with the command make uninstall cloud=heroku Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( yarn or npm ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#service-nodejs-with-expressjs","text":"Container: \"hello-cloud/our-hello-nodejs-expressjs-webapi\" Source: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS Language: JavaScript Framework: ExpressJS","title":"Service: NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/nodejs-expressjs/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":" DevOps"},{"location":"services/nodejs-expressjs/#deployments","text":"","title":"Deployments"},{"location":"services/nodejs-expressjs/#docker","text":"Run as a container The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:3000/ . docker run \\ --name = our-hello-nodejs-expressjs-webapi \\ --detach \\ --publish = 3000 :3000 \\ ghcr.io/ourchitecture/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image .","title":" Docker"},{"location":"services/nodejs-expressjs/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make install cloud=aws ) Initialize and install (deploy) with the command make install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/nodejs-expressjs/#amazon-web-services-aws","text":"Prerequisites See the contributor guide for more details. An AWS account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/aws/.env.example\" file and save it as a new file \"./deploy/aws/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/aws/.env\" and replace the values according to preferences. If required, for the values \"AWS_ACCESS_KEY_ID\" and \"AWS_SECRET_ACCESS_KEY\", create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Run the command make install cloud=aws to create the AWS Elastic Beanstalk Environment and install the application. This command may take a few minutes. Update the application with the same command make install cloud=aws . Check the application logs with the command make logs cloud=aws Uninstall and clean up the application deployment with the command make uninstall cloud=aws . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/nodejs-expressjs/#microsoft-azure","text":"Prerequisites See the contributor guide for more details. An Azure account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/azure/.env.example\" file and save it as a new file \"./deploy/azure/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/azure/.env\" and replace the values according to preferences. If required, for the values \"AZURE_SP_APPID\", \"AZURE_SP_PASSWORD\", and \"AZURE_SP_TENANT\", create new service principal credentials with the Azure CLI and the command az ad sp create-for-rbac --name \"our-hello-sp\" --role Contributor , providing any --name as desired. *You may encounter an error with multiple subscriptions as this has not been tested. Consider a contribution . Run the command make install cloud=azure to create the Azure Resource Group, Azure AppService Plan, and AppService if they do not exist as well as to deploy the application. Check the application logs with the command make logs cloud=azure Uninstall and clean up the application deployment with the command make uninstall cloud=azure","title":" Microsoft Azure"},{"location":"services/nodejs-expressjs/#google-cloud","text":"Prerequisites See the contributor guide for more details. A Google Cloud account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation Google Cloud Billing Account Once a project is created, you will be prompted to enable Google Cloud Build git for source control. GNU make for standard task execution. docker for containerized task execution. Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Cloud Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/gcloud/.env.example\" file and save it as a new file \"./deploy/gcloud/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/gcloud/.env\" and replace the values according to preferences. Run the command make install cloud=gcloud to create a new Google Cloud project, application, and deploy the code. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) If the output indicates that \"Cloud Build\" must be enabled, login to the projects list and enable the cloud build API Check the application logs with the command make logs cloud=gcloud Uninstall and clean up the application deployment with the command make uninstall cloud=gcloud Tip: Project Naming Google Cloud retains deleted projects for a time. If the value for \"GCLOUD_PROJECT_ID\" in \"./deploy/gcloud/.env\" already exists as an active project, nothing will be done. If the project has been deleted, the project will be restored. If the project does not exist, it will be created.","title":" Google Cloud"},{"location":"services/nodejs-expressjs/#salesforce-heroku","text":"Prerequisites See the contributor guide for more details. A Heroku account *this project worked with fairly cheap or entirely free infrastructure at the time of its creation git for source control. GNU make for standard task execution. docker for containerized task execution. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Copy the \"./deploy/heroku/.env.example\" file and save it as a new file \"./deploy/heroku/.env\". *This new file will not be committed back to source control as it contains personal and sensitive data. Edit the file \"./deploy/heroku/.env\" and replace the values according to preferences. Run the command make install cloud=heroku to create a new Heroku application and deploy the code. Check the application logs with the command make logs cloud=heroku Uninstall and clean up the application deployment with the command make uninstall cloud=heroku","title":" SalesForce Heroku"},{"location":"services/nodejs-expressjs/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" HTTPS only deployment GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( yarn or npm ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Roadmap"}]}