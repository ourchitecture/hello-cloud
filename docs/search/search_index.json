{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello Cloud \ud83d\udc4b\ud83c\udffc Hello and welcome! This project contains examples of \"hello world\" automation deployed to major cloud providers. While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by their DevOps pipeline continuous integration and deployment workflows. Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. \u270d\ud83c\udffc Make a contribution \u267e\ufe0f Learn about the DevOps pipeline Web Services .NET Java with SpringBoot NodeJS with ExpressJS Docker hello-cloud/our-hello-dotnet-webapi hello-cloud/our-hello-java-springboot-webapi hello-cloud/our-hello-nodejs-expressjs-webapi General Roadmap See specific projects for their unique roadmaps. Started \u2699\ufe0f .NET Core C# service example Future \u2b1c Python service example \u2b1c Go service example \u2b1c Angular web example \u2b1c React web example \u2b1c Vue web example \u2b1c Ionic stencil web example \u2b1c Containerized web example(s) Completed \u2705 Documentation automation wit MkDocs \u2705 NodeJS with ExpressJS service example \u2705 Java with SpringBoot service example \u2705 Amazon Web Services cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Microsoft Azure cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Google Cloud cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Salesforce Heroku cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Containerized service example(s) (NodeJS with ExpressJS, Java with SpringBoot) \u2705 GitHub Actions workflow \u2705 GitHub Packages with GitHub Container Registry \u2705 Developer tool choices (e.g. docker vs. docker-compose vs. podman vs. [ yarn vs. npm OR gradle vs. maven ])","title":"Home"},{"location":"#hello-cloud","text":"\ud83d\udc4b\ud83c\udffc Hello and welcome! This project contains examples of \"hello world\" automation deployed to major cloud providers. While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by their DevOps pipeline continuous integration and deployment workflows. Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. \u270d\ud83c\udffc Make a contribution \u267e\ufe0f Learn about the DevOps pipeline","title":"Hello Cloud"},{"location":"#web-services","text":".NET Java with SpringBoot NodeJS with ExpressJS","title":"Web Services"},{"location":"#docker","text":"hello-cloud/our-hello-dotnet-webapi hello-cloud/our-hello-java-springboot-webapi hello-cloud/our-hello-nodejs-expressjs-webapi","title":"Docker"},{"location":"#general-roadmap","text":"See specific projects for their unique roadmaps.","title":"General Roadmap"},{"location":"#started","text":"\u2699\ufe0f .NET Core C# service example","title":"Started"},{"location":"#future","text":"\u2b1c Python service example \u2b1c Go service example \u2b1c Angular web example \u2b1c React web example \u2b1c Vue web example \u2b1c Ionic stencil web example \u2b1c Containerized web example(s)","title":"Future"},{"location":"#completed","text":"\u2705 Documentation automation wit MkDocs \u2705 NodeJS with ExpressJS service example \u2705 Java with SpringBoot service example \u2705 Amazon Web Services cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Microsoft Azure cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Google Cloud cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Salesforce Heroku cloud deployment example(s) (NodeJS with ExpressJS) \u2705 Containerized service example(s) (NodeJS with ExpressJS, Java with SpringBoot) \u2705 GitHub Actions workflow \u2705 GitHub Packages with GitHub Container Registry \u2705 Developer tool choices (e.g. docker vs. docker-compose vs. podman vs. [ yarn vs. npm OR gradle vs. maven ])","title":"Completed"},{"location":"contribute/","text":"Contributing \ud83d\udc4b\ud83c\udffc Welcome and we are glad you are interested in contributing! Development This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against. Prerequisites \u26a0\ufe0f Windows users: \ud83d\udc49\ud83c\udffc task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) \ud83d\udd17 is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH \ud83d\udd17 with make for Git BASH \ud83d\udd17 installed or cygwin \ud83d\udd17 with make for cygwin \ud83d\udd17 installed. You could also use a Linux virtual machine running on Windows Hyper-V \ud83d\udd17, Oracle VirtualBox \ud83d\udd17, or even using a VS Code \"devcontainer\" \ud83d\udd17. Tools Required git \ud83d\udd17 for source control. docker \ud83d\udd17, docker-compose \ud83d\udd17, or podman \ud83d\udd17 are required to build the documentation and production container images. Recommended GNU make \ud83d\udd17 is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above ) Optional yarn \ud83d\udd17 or node \ud83d\udd17 are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm \ud83d\udd17 can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK \ud83d\udd17 is required to run Java projects. However, container runtimes make this installation optional. dotnet 6 SDK \ud83d\udd17 is required to run .NET projects. However, container runtimes make this installation optional. VS code \ud83d\udd17 may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town \ud83d\udd17 may be used for improved developer workflow. Avoid Use of a global installations of gradle and/or maven are not needed or recommended. This project uses Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines. Executing tasks Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker \ud83d\udc33; while this project would prefer to use a completely free and open source ecosystem like podman \ud83e\udd70\ud83d\udc96, docker is well established, virtually ubiquitous on most local and DevOps machines, and mostly free \ud83d\udd17 \ud83d\udcb8. All automation tasks are abstracted behind make \u2699\ufe0f command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default tool used by DevOps pipeline tasks for production build, test, and deploy. If you do not wish to use make (e.g. npm install && npm start or yarn && yarn start ; ./gradlew bootRun or ./mvnw spring-boot:run ; dotnet run ), review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work. Running tasks Clone the repository with the command git clone --depth=1 https://github.com/ericis/hello-cloud Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Command + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work)","title":"Contribute"},{"location":"contribute/#contributing","text":"\ud83d\udc4b\ud83c\udffc Welcome and we are glad you are interested in contributing!","title":"Contributing"},{"location":"contribute/#development","text":"This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against.","title":"Development"},{"location":"contribute/#prerequisites","text":"\u26a0\ufe0f Windows users: \ud83d\udc49\ud83c\udffc task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) \ud83d\udd17 is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH \ud83d\udd17 with make for Git BASH \ud83d\udd17 installed or cygwin \ud83d\udd17 with make for cygwin \ud83d\udd17 installed. You could also use a Linux virtual machine running on Windows Hyper-V \ud83d\udd17, Oracle VirtualBox \ud83d\udd17, or even using a VS Code \"devcontainer\" \ud83d\udd17.","title":"Prerequisites"},{"location":"contribute/#tools","text":"","title":"Tools"},{"location":"contribute/#required","text":"git \ud83d\udd17 for source control. docker \ud83d\udd17, docker-compose \ud83d\udd17, or podman \ud83d\udd17 are required to build the documentation and production container images.","title":"Required"},{"location":"contribute/#recommended","text":"GNU make \ud83d\udd17 is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above )","title":"Recommended"},{"location":"contribute/#optional","text":"yarn \ud83d\udd17 or node \ud83d\udd17 are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm \ud83d\udd17 can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK \ud83d\udd17 is required to run Java projects. However, container runtimes make this installation optional. dotnet 6 SDK \ud83d\udd17 is required to run .NET projects. However, container runtimes make this installation optional. VS code \ud83d\udd17 may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town \ud83d\udd17 may be used for improved developer workflow.","title":"Optional"},{"location":"contribute/#avoid","text":"Use of a global installations of gradle and/or maven are not needed or recommended. This project uses Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines.","title":"Avoid"},{"location":"contribute/#executing-tasks","text":"Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker \ud83d\udc33; while this project would prefer to use a completely free and open source ecosystem like podman \ud83e\udd70\ud83d\udc96, docker is well established, virtually ubiquitous on most local and DevOps machines, and mostly free \ud83d\udd17 \ud83d\udcb8. All automation tasks are abstracted behind make \u2699\ufe0f command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default tool used by DevOps pipeline tasks for production build, test, and deploy. If you do not wish to use make (e.g. npm install && npm start or yarn && yarn start ; ./gradlew bootRun or ./mvnw spring-boot:run ; dotnet run ), review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work.","title":"Executing tasks"},{"location":"contribute/#running-tasks","text":"Clone the repository with the command git clone --depth=1 https://github.com/ericis/hello-cloud Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Command + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work)","title":"Running tasks"},{"location":"devops/","text":"DevOps Local development See the contributor guide for local development. Pipelines Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" . Documentation Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs \ud83d\udd17, Material for MkDocs \ud83d\udd17, and the \"mkdocs-material\" \ud83d\udd17 dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"DevOps"},{"location":"devops/#devops","text":"","title":"DevOps"},{"location":"devops/#local-development","text":"See the contributor guide for local development.","title":"Local development"},{"location":"devops/#pipelines","text":"Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" .","title":"Pipelines"},{"location":"devops/#documentation","text":"Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs \ud83d\udd17, Material for MkDocs \ud83d\udd17, and the \"mkdocs-material\" \ud83d\udd17 dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"Documentation"},{"location":"license/","text":"License Everything in the project except \"./src/media/\" falls under \"Creative Commons Zero v1.0 Universal\". Media Path: \"./src/media/\" Media contained in this directory may have stricter licensing restrictions. Read the unique licensing concerns listed below... \"./icons/logo/logo.svg\" may not be redistributed and is licensed to Eric Swanson from thenounproject.com","title":"License"},{"location":"license/#license","text":"Everything in the project except \"./src/media/\" falls under \"Creative Commons Zero v1.0 Universal\".","title":"License"},{"location":"license/#media","text":"Path: \"./src/media/\" Media contained in this directory may have stricter licensing restrictions. Read the unique licensing concerns listed below... \"./icons/logo/logo.svg\" may not be redistributed and is licensed to Eric Swanson from thenounproject.com","title":"Media"},{"location":"services/dotnet/","text":"Service: .NET Core Path: ./src/services/dotnet/webapi/ Runtime: .NET Core \ud83d\udd17 Language: C# \ud83d\udd17 Framework: ASP.NET \ud83d\udd17 Getting started The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-dotnet-webapi --detach --publish=5124:80 ghcr.io/ericis/hello-cloud/our-hello-dotnet-webapi:latest and then browse to http://localhost:5124/). DevOps Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container Deployments Docker The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image . Roadmap \u2705 Local \"hello-cloud\" service ( dotnet ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2b1c Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":".NET"},{"location":"services/dotnet/#service-net-core","text":"Path: ./src/services/dotnet/webapi/ Runtime: .NET Core \ud83d\udd17 Language: C# \ud83d\udd17 Framework: ASP.NET \ud83d\udd17","title":"Service: .NET Core"},{"location":"services/dotnet/#getting-started","text":"The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-dotnet-webapi --detach --publish=5124:80 ghcr.io/ericis/hello-cloud/our-hello-dotnet-webapi:latest and then browse to http://localhost:5124/).","title":"Getting started"},{"location":"services/dotnet/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container","title":"DevOps"},{"location":"services/dotnet/#deployments","text":"","title":"Deployments"},{"location":"services/dotnet/#docker","text":"The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image .","title":"Docker"},{"location":"services/dotnet/#roadmap","text":"\u2705 Local \"hello-cloud\" service ( dotnet ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2b1c Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":"Roadmap"},{"location":"services/java-springboot/","text":"Service: Java with SpringBoot Path: ./src/services/java/springboot/webapi/ Runtime: OpenJDK \ud83d\udd17 Language: Java \ud83d\udd17 Framework: SpringBoot \ud83d\udd17 Getting started The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-java-springboot-webapi --detach --publish=8080:8080 ghcr.io/ericis/hello-cloud/our-hello-java-springboot-webapi:latest and then browse to http://localhost:8080/). DevOps Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container Deployments Docker The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image . Multi-cloud While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account \ud83d\udd17 ( this project worked with free infrastructure at the time of its creation ) eb CLI \ud83d\udd17 Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" \ud83d\udd17, expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account \ud83d\udd17 ( this project worked with free infrastructure at the time of its creation ) az CLI \ud83d\udd17 java 11 OpenJDK \ud83d\udd17 (required to execute ./mvnw commands) Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Steps to deploy Every attempt is made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=01 to create the Google Cloud project Install the application with the command make gcloud-install . If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 *Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap \u2705 Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2705 Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":"Java with SpringBoot"},{"location":"services/java-springboot/#service-java-with-springboot","text":"Path: ./src/services/java/springboot/webapi/ Runtime: OpenJDK \ud83d\udd17 Language: Java \ud83d\udd17 Framework: SpringBoot \ud83d\udd17","title":"Service: Java with SpringBoot"},{"location":"services/java-springboot/#getting-started","text":"The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-java-springboot-webapi --detach --publish=8080:8080 ghcr.io/ericis/hello-cloud/our-hello-java-springboot-webapi:latest and then browse to http://localhost:8080/).","title":"Getting started"},{"location":"services/java-springboot/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container","title":"DevOps"},{"location":"services/java-springboot/#deployments","text":"","title":"Deployments"},{"location":"services/java-springboot/#docker","text":"The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image .","title":"Docker"},{"location":"services/java-springboot/#multi-cloud","text":"While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/java-springboot/#amazon-web-services-aws","text":"","title":"Amazon Web Services (AWS)"},{"location":"services/java-springboot/#prerequisites","text":"An AWS account \ud83d\udd17 ( this project worked with free infrastructure at the time of its creation ) eb CLI \ud83d\udd17","title":"Prerequisites"},{"location":"services/java-springboot/#steps-to-deploy","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" \ud83d\udd17, expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":"Steps to deploy"},{"location":"services/java-springboot/#microsoft-azure","text":"","title":"Microsoft Azure"},{"location":"services/java-springboot/#prerequisites_1","text":"An Azure account \ud83d\udd17 ( this project worked with free infrastructure at the time of its creation ) az CLI \ud83d\udd17 java 11 OpenJDK \ud83d\udd17 (required to execute ./mvnw commands)","title":"Prerequisites"},{"location":"services/java-springboot/#steps-to-deploy_1","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":"Steps to deploy"},{"location":"services/java-springboot/#google-cloud","text":"","title":"Google Cloud"},{"location":"services/java-springboot/#prerequisites_2","text":"An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account","title":"Prerequisites"},{"location":"services/java-springboot/#steps-to-deploy_2","text":"Every attempt is made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=01 to create the Google Cloud project Install the application with the command make gcloud-install . If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 *Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":"Steps to deploy"},{"location":"services/java-springboot/#salesforce-heroku","text":"","title":"SalesForce Heroku"},{"location":"services/java-springboot/#prerequisites_3","text":"A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI","title":"Prerequisites"},{"location":"services/java-springboot/#steps-to-deploy_3","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":"Steps to deploy"},{"location":"services/java-springboot/#roadmap","text":"\u2705 Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2705 Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":"Roadmap"},{"location":"services/nodejs-expressjs/","text":"Service: NodeJS with ExpressJS Path: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS \ud83d\udd17 Language: JavaScript \ud83d\udd17 Framework: ExpressJS \ud83d\udd17 Getting started The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-nodejs-expressjs-webapi --detach --publish=3000:3000 ghcr.io/ericis/hello-cloud/our-hello-nodejs-expressjs-webapi:latest and then browse to http://localhost:3000/). DevOps Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/nodejs_expressjs_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image . Multi-cloud While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account *this project worked with free infrastructure at the time of its creation eb CLI Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account *this project worked with free infrastructure at the time of its creation az CLI Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Enable Google Cloud Build with the command gcloud services enable cloudbuild.googleapis.com Steps to deploy Every attempt is made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=01 to create the Google Cloud project Install the application with the command make gcloud-install If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 *Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Steps to deploy Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the node.js buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap \u2705 Local \"hello-cloud\" service ( yarn or npm ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2705 Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":"NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#service-nodejs-with-expressjs","text":"Path: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS \ud83d\udd17 Language: JavaScript \ud83d\udd17 Framework: ExpressJS \ud83d\udd17","title":"Service: NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#getting-started","text":"The contributor guide has the steps necessary to run this project locally. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman (e.g. docker run --name=our-hello-nodejs-expressjs-webapi --detach --publish=3000:3000 ghcr.io/ericis/hello-cloud/our-hello-nodejs-expressjs-webapi:latest and then browse to http://localhost:3000/).","title":"Getting started"},{"location":"services/nodejs-expressjs/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":"DevOps"},{"location":"services/nodejs-expressjs/#deployments","text":"","title":"Deployments"},{"location":"services/nodejs-expressjs/#docker","text":"The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/nodejs_expressjs_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image .","title":"Docker"},{"location":"services/nodejs-expressjs/#multi-cloud","text":"While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/nodejs-expressjs/#amazon-web-services-aws","text":"","title":"Amazon Web Services (AWS)"},{"location":"services/nodejs-expressjs/#prerequisites","text":"An AWS account *this project worked with free infrastructure at the time of its creation eb CLI","title":"Prerequisites"},{"location":"services/nodejs-expressjs/#steps-to-deploy","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":"Steps to deploy"},{"location":"services/nodejs-expressjs/#microsoft-azure","text":"","title":"Microsoft Azure"},{"location":"services/nodejs-expressjs/#prerequisites_1","text":"An Azure account *this project worked with free infrastructure at the time of its creation az CLI","title":"Prerequisites"},{"location":"services/nodejs-expressjs/#steps-to-deploy_1","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":"Steps to deploy"},{"location":"services/nodejs-expressjs/#google-cloud","text":"","title":"Google Cloud"},{"location":"services/nodejs-expressjs/#prerequisites_2","text":"An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Enable Google Cloud Build with the command gcloud services enable cloudbuild.googleapis.com","title":"Prerequisites"},{"location":"services/nodejs-expressjs/#steps-to-deploy_2","text":"Every attempt is made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=01 to create the Google Cloud project Install the application with the command make gcloud-install If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 *Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":"Steps to deploy"},{"location":"services/nodejs-expressjs/#salesforce-heroku","text":"","title":"SalesForce Heroku"},{"location":"services/nodejs-expressjs/#prerequisites_3","text":"A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI","title":"Prerequisites"},{"location":"services/nodejs-expressjs/#steps-to-deploy_3","text":"Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the node.js buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":"Steps to deploy"},{"location":"services/nodejs-expressjs/#roadmap","text":"\u2705 Local \"hello-cloud\" service ( yarn or npm ) \u2705 Build and run as container ( docker , docker-compose , or podman ) \u2705 Deploy container to GitHub Container Registry as GitHub Package \u2705 GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package \u2705 Deploy to cloud Platform-as-a-Service (PaaS) (\"aws\", \"azure\", \"gcloud\", \"heroku\") \u2b1c Deploy to cloud Managed Containers (\"aws\", \"azure\", \"gcloud\", \"heroku\") *prefer \"run as container\" deployment over full-blown Managed Kubernetes deployment \u2b1c GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) \u2b1c Service contracts and auto-generated documentation integrated with MkDocs documentation site \u2b1c Ping / Health endpoint","title":"Roadmap"}]}